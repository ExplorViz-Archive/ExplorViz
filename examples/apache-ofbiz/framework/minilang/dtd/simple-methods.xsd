<?xml version="1.0" encoding="UTF-8"?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
<!--
    ==================================================
    ========== The Simple Methods Section ==========
    ==================================================
    (see further down for the Simple Map Processor Section)
-->

  <!-- Reusable artifacts (abstract elements, groups, attributeGroups -->
    <xs:element name="CallOperations" abstract="true"/>
    <xs:element name="EventOperations" abstract="true"/>
    <xs:element name="ServiceOperations" abstract="true"/>
    <xs:element name="EnvOperations" abstract="true"/>
    <xs:element name="EntityMiscOperations" abstract="true"/>
    <xs:element name="EntityFindOperations" abstract="true"/>
    <xs:element name="EntityValueOperations" abstract="true"/>
    <xs:element name="EntityListOperations" abstract="true"/>
    <xs:element name="EntityTxOperations" abstract="true"/>
    <xs:element name="ControlOperations" abstract="true"/>
    <xs:element name="IfBasicOperations" abstract="true"/>
    <xs:element name="IfOtherOperations" abstract="true"/>
    <xs:element name="OtherOperations" abstract="true"/>
    <xs:group name="AllOperations"> <!-- Any simple-method operation can be nested under an if-* tag. -->
        <xs:choice>
            <xs:element ref="CallOperations"/>
            <xs:element ref="EventOperations"/>
            <xs:element ref="ServiceOperations"/>
            <xs:element ref="EnvOperations"/>
            <xs:element ref="EntityMiscOperations"/>
            <xs:element ref="EntityFindOperations"/>
            <xs:element ref="EntityValueOperations"/>
            <xs:element ref="EntityListOperations"/>
            <xs:element ref="EntityTxOperations"/>
            <xs:element ref="ControlOperations"/>
            <xs:element ref="IfBasicOperations"/>
            <xs:element ref="IfOtherOperations"/>
            <xs:element ref="OtherOperations"/>
        </xs:choice>
    </xs:group>

    <xs:attributeGroup name="attlist.propertyInfoOptional">
        <xs:attribute type="xs:string" name="resource"/>
        <xs:attribute type="xs:string" name="property"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="attlist.typeDefaultString">
        <xs:attribute name="type" default="String">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="PlainString"/>
                    <xs:enumeration value="String"/>
                    <xs:enumeration value="BigDecimal"/>
                    <xs:enumeration value="Double"/>
                    <xs:enumeration value="Float"/>
                    <xs:enumeration value="Long"/>
                    <xs:enumeration value="Integer"/>
                    <xs:enumeration value="Date"/>
                    <xs:enumeration value="Time"/>
                    <xs:enumeration value="Timestamp"/>
                    <xs:enumeration value="Boolean"/>
                    <xs:enumeration value="Object"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="attlist.operatorRequired">
        <xs:attribute name="operator" use="required">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="less"/>
                    <xs:enumeration value="greater"/>
                    <xs:enumeration value="less-equals"/>
                    <xs:enumeration value="greater-equals"/>
                    <xs:enumeration value="equals"/>
                    <xs:enumeration value="not-equals"/>
                    <xs:enumeration value="contains"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>

  <!-- ELEMENTS start here -->
    <xs:element name="field">
        <xs:annotation>
            <xs:documentation>
                Used to specify a field to be passed as an argument to the method call.
                The field can be in a map in the environment or if no map-name is specified
                then the field will come directly from the environment.

                With the "." Syntax, the map-name is typically no longer necessary because
                you can do map-name.field-name in the field-name attribute, but those are still there for legacy purposes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.field">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>Name of the field to put value in.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="type">
            <xs:annotation>
                <xs:documentation>
                    Type of the value put in the field.
                    If this is a method call or object creation and the type in the method signature being called is for a parent class or interface,
                    then it should be the type in that parent class or interface and not the type of the object being passed in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="string">
        <xs:annotation>
            <xs:documentation>
                String of type java.lang.String. Inserts the value of the inline string where specified.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.string"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.string">
        <xs:attribute type="xs:string" name="value"/>
    </xs:attributeGroup>
    <xs:element name="simple-methods">
        <xs:annotation>
            <xs:documentation>
                Opening tag of simple-method files.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element maxOccurs="unbounded" ref="simple-method">
                    <xs:annotation>
                        <xs:documentation>
                            Opening tag of a simple-method definition.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="simple-method">
        <xs:annotation>
            <xs:documentation>
                A simple method can be called in either an event context from the Control
                Servlet (or another event) or in a service context through the Service
                Engine, or any other component that has access to a service dispatcher.

                The field-to-request and field-to-session elements will be IGNORED when
                called in a service context. So, they are ONLY used when called in an event context.

                The field-to-result elements will be ignored in an event context, ie only used in a service.

                The parameter-map-name env entry will contain the HttpRequest parameters for
                running in an event context and and the input context when running in a service.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
            <xs:attributeGroup ref="attlist.simple-method"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.simple-method">
        <xs:attribute type="xs:string" name="method-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    A name (preferably a legal Java identifier) for this method.
                    This name must be unique for the XML file it is in as it will be used to reference this method externally.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="short-description" use="required">
            <xs:annotation>
                <xs:documentation>
                    A short description of the method for certain system error messages.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="login-required" default="true">
            <xs:annotation>
                <xs:documentation>
                    Is a logged in user (UserLogin object, or login.username and login.password Strings) required to run this method?
                    "true" or "false" (defauts to "true")
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="use-transaction" default="true">
            <xs:annotation>
                <xs:documentation>
                    Create a transaction if none exists for this thread?
                    "true" or "false" (defauts to "true")
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default-error-code" default="error">
            <xs:annotation>
                <xs:documentation>
                    The default error return code. (defauts to "error")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default-success-code" default="success">
            <xs:annotation>
                <xs:documentation>
                    The default success return code.  (defauts to "success")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="parameter-map-name" default="parameters">
            <xs:annotation>
                <xs:documentation>
                    As event: copy of request parameters.
                    As service: incoming context.
                    (defauts to "parameters")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="event-request-object-name" default="request">
            <xs:annotation>
                <xs:documentation>
                    As event only (defauts to "request")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="event-response-object-name" default="response">
            <xs:annotation>
                <xs:documentation>
                    As event only (defauts to "response")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="event-response-code-name" default="_response_code_">
            <xs:annotation>
                <xs:documentation>
                    As event only (defauts to "_response_code")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="event-error-message-name" default="_error_message_">
            <xs:annotation>
                <xs:documentation>
                    As event only (defauts to "_error_message_")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="event-event-message-name" default="_event_message_">
            <xs:annotation>
                <xs:documentation>
                    As event only (defauts to "_event_message_")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="service-response-message-name" default="responseMessage">
            <xs:annotation>
                <xs:documentation>
                    As service only (defauts to "responseMessage")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="service-error-message-name" default="errorMessage">
            <xs:annotation>
                <xs:documentation>
                    As service only (defauts to "errorMessage")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="service-error-message-list-name" default="errorMessageList">
            <xs:annotation>
                <xs:documentation>
                    As service only (defauts to "errorMessageList")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="service-error-message-map-name" default="errorMessageMap">
            <xs:annotation>
                <xs:documentation>
                    As service only (defauts to "errorMessageMap")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="service-success-message-name" default="successMessage">
            <xs:annotation>
                <xs:documentation>
                    As service only (defauts to "successMessage")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="service-success-message-list-name" default="successMessageList">
            <xs:annotation>
                <xs:documentation>
                    As service only (defauts to "successMessageList")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="locale-name" default="locale">
            <xs:annotation>
                <xs:documentation>
                    Name of locale variable (defauts to "locale")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="delegator-name" default="delegator">
            <xs:annotation>
                <xs:documentation>
                    A GenericDelegator object to use in the method (defauts to "delegator")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="security-name" default="security">
            <xs:annotation>
                <xs:documentation>
                    A Security object to use in the method (defauts to "security")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="dispatcher-name" default="dispatcher">
            <xs:annotation>
                <xs:documentation>
                    A LocalDispatcher object to use in the method (defauts to "dispatcher")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="user-login-name" default="userLogin">
            <xs:annotation>
                <xs:documentation>
                    Name of user login variable (defauts to "userLogin")
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="call-map-processor" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                The call-map-processor tag invokes a simple map processor from an existing map, creating a new map or adding to an existing one
                if the named out-map already exists. Resulting messages are added to the named list, and a new list is created if a list with
                the given name does not yet exist. Note that all lists and maps exist in the same context and must have unique names.

                An inline simple-map-processor can be used by putting a simple-map-processor tag under the call-map-processor tag.

                If both an external and an inline map-processor are specified, the external
                one will be called first, allowing the inline one to override its behavior.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" ref="simple-map-processor">
                    <xs:annotation>
                        <xs:documentation>
                            Uses the same definition as the simple-map-processor in the context of a simple-map-processors XML file.
                            Allows for an inlined simple-map-processor.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.call-map-processor"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.call-map-processor">
        <xs:attribute type="xs:string" name="xml-resource">
            <xs:annotation>
                <xs:documentation>
                    The full path and filename on the classpath of the XML file which contains an external map processor to execute.
                    This is only required if an external map processor is desired.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="processor-name">
            <xs:annotation>
                <xs:documentation>
                    The name of the external map processor to execute in the specified xml-resource.
                    This is only required if an external map processor is desired.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="in-map-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment to use as the input map.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="out-map-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment to use as the output map.
                    Will be created if it does not exist already.
                    If already exists will be added to in place.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of a list in the method environment that the error messages will be added to.
                    Will be created if it does not exist.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="set-service-fields" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                Take all the incoming files for this service, or all the incoming service attributes,
                and look for fields with the same name in the incoming map and copy those onto the outgoing map.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.set-service-fields"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.set-service-fields">
        <xs:attribute type="xs:string" name="service-name" use="required">
            <xs:annotation><xs:documentation>Name of the service to get all the incoming attributes (parameters) from.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map" use="required">
            <xs:annotation><xs:documentation>Incoming map to copy fields from.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="to-map" use="required">
            <xs:annotation><xs:documentation>Map to copy to fields to.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of a list in the method environment that the error messages will be added to.
                    Will be created if it does not exist.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="call-service" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                The call-service tag invokes a service through the Service Engine.
                If the specified error code is returned from the service,
                the event is aborted and the transaction in the current thread is rolled back.
                Otherwise, the remaining operations are invoked.

                The result-to-request and result-to-session elements will be IGNORED when
                called in a service context. So, they are ONLY used when called in an event context.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" ref="error-prefix"/>
                <xs:element minOccurs="0" ref="error-suffix"/>
                <xs:element minOccurs="0" ref="success-prefix"/>
                <xs:element minOccurs="0" ref="success-suffix"/>
                <xs:element minOccurs="0" ref="message-prefix"/>
                <xs:element minOccurs="0" ref="message-suffix"/>
                <xs:element minOccurs="0" ref="default-message"/>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:element ref="results-to-map"/>
                    <xs:element ref="result-to-field"/>
                    <xs:element ref="result-to-request"/>
                    <xs:element ref="result-to-session"/>
                    <xs:element ref="result-to-result"/>
                </xs:choice>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.call-service"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.call-service">
        <xs:attribute type="xs:string" name="service-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the service to call.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="in-map-name">
            <xs:annotation>
                <xs:documentation>
                    Optional name of a map in the method environment to use as the input map.
                    If you're not going to pass any parameters to the service than you can just
                    leave off the in-map name, although typically in a service tag you will see
                    a service-name and the in-mapname passed in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="include-user-login" default="true">
            <xs:annotation>
                <xs:documentation>
                    Include-user-login by default will include the user login
                    so if there is a user login for the current simple-method
                    it will pass that in to the service. If you don't want it to
                    pass that in you can just set this to false.
                    Defaults to "true".
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:annotation>
                </xs:annotation>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="break-on-error" default="true">
            <xs:annotation>
                <xs:documentation>
                    If there's an error in the service by default
                    it will stop the current simple-method and return an
                    error message that came from the service it called. If
                    you don't want it to when there's an error you can just
                    set that to false.
                    Defaults to "true".
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-code" default="error">
            <xs:annotation>
                <xs:documentation>
                    Defaults to "error".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="success-code" default="success">
            <xs:annotation>
                <xs:documentation>
                    Defaults to "success".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="require-new-transaction" default="false">
            <xs:annotation>
                <xs:documentation>
                    Defines if the simple-method requires a new transaction or not.
                    Defaults to "false".
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="transaction-timeout">
            <xs:annotation>
                <xs:documentation>
                    Defines the timeout for the transaction, in seconds.
                    Defaults to the value set in the service definition which in turn defaults to the setting 
                    in the TransactionFactory being used (typically 60 seconds).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="error-prefix">
        <xs:annotation>
            <xs:documentation>
                Specify a resource and a property to prepend to the error message.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.propertyInfoOptional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="error-suffix">
        <xs:annotation>
            <xs:documentation>
                Specify a resource and a property to append to the error message.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.propertyInfoOptional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="success-prefix">
        <xs:annotation>
            <xs:documentation>
                Specify a resource and a property to prepend to the success message.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.propertyInfoOptional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="success-suffix">
        <xs:annotation>
            <xs:documentation>
                Specify a resource and a property to append to the success message.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.propertyInfoOptional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="message-prefix">
        <xs:annotation>
            <xs:documentation>
                Specify a resource and a property to prepend to any kind of message.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.propertyInfoOptional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="message-suffix">
        <xs:annotation>
            <xs:documentation>
                Specify a resource and a property to append to any kind of message.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.propertyInfoOptional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="default-message">
        <xs:annotation>
            <xs:documentation>
                Message that you can specify for the case where the service does not return a message.
                You can just specify a default-message to use as if the service had returned that default-message.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.propertyInfoOptional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="results-to-map">
        <xs:annotation>
            <xs:documentation>
                results-to-map will take all of the results of the service,
                the outgoing maps from the service and put them in a map of the given map-name.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.results-to-map"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.results-to-map">
        <xs:attribute type="xs:string" name="map-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a map where results will be put in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="result-to-field">
        <xs:annotation>
            <xs:documentation>
                Specify the name of the field in the result and then the name of the field in the context you want to put it in,
                and optionally the  name in the map.

                There's a field-map there. If you don't specify a field-name then the result-name will be used for the field-name,
                that's the name of the variable that will be created in the current context for the value of that result.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.result-to-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.result-to-field">
        <xs:attribute type="xs:string" name="result-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the result. May be used for the field-name. If you don't specify a field-name,
                    this will be name of the variable that will be created in the current context for the value of that result.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="field">
            <xs:annotation><xs:documentation>Optional name of target field. If empty will default to result-name.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="result-to-request">
        <xs:annotation>
            <xs:documentation>
                result-to-request is event specific.
                It takes the result with the given name and puts it in a request attribute with the given name here.
                Again the request-name is optional.
                If you leave it off then it will put it in an attribute with the name of the result-name.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.result-to-request"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.result-to-request">
        <xs:attribute type="xs:string" name="result-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the result. May be used for the request attribute name. If you don't specify a request-name ,
                    that's the name of the request attribute that will be created for the value of that result.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="request-name">
            <xs:annotation>
                <xs:documentation>
                    Optionnal request name.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="result-to-session">
        <xs:annotation>
            <xs:documentation>
                Specify the name of the session attribute that you want it to put the value in.
                If you don't specify one it will use the result-name.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.result-to-session"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.result-to-session">
        <xs:attribute type="xs:string" name="result-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the result. May be used for the session attribute name. If you don't specify a session-name,
                    that's the name of the session attribute that will be created for the value of that result.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="session-name">
            <xs:annotation>
                <xs:documentation>
                    Optionnal session name.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="result-to-result">
        <xs:annotation>
            <xs:documentation>
                result-to-result is service specific (when the service is being called as a service).

                It will take the result of the service you're calling with the call service operation and it will put it in with the result of the current service.
                So result-name is the name of the result in the service that was called using the call-service tag.

                NOTE that these attributes are somewhat confusing: result-name is the name of the field in the result of this service call that the value comes FROM;
                service-result-name is the name of the field in the result of this simple-method called as a service where the value goes TO;
                in other words FROM result-name and TO service-result-name.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.result-to-result"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.result-to-result">
        <xs:attribute type="xs:string" name="result-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the field in the result of this service call that the value comes FROM.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="service-result-name">
            <xs:annotation>
                <xs:documentation>
                    Name of the field in the result of this simple-method called as a service where the value goes TO.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="call-service-asynch" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                Calls a service asynchronously and ignores the result, so no return messages
                are used; that doesn't mean no errors will result, but they would just be
                system errors like database failures, etc. which all have system error messages.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.call-service-asynch"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.call-service-asynch">
        <xs:attribute type="xs:string" name="service-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the service called asynchronously.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="in-map-name">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment to use as the input map.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="include-user-login" default="true">
            <xs:annotation>
                <xs:documentation>
                    Defaults to "true".
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="script" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                Runs an external script (minilang, bsh, groovy) from the expanded location provided.               
                Error messages go on the error list and are handled with the check-errors tag.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.script"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.script">
        <xs:attribute type="xs:string" name="location">
            <xs:annotation>
                <xs:documentation>
                    Script location (component://...)
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of the list in the method environment to check for error messages.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="call-bsh" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                Runs an external bsh script from the classpath if resource is specified and
                then runs the inlined bsh script if any is specified.

                The bsh context is the current simple-method environment including maps, lists
                and special objects whose names are defined in the simple-method attributes.

                The current env cannot be modified, but if a Map is returned by the bsh block
                the entries in the map will be put into the current env.

                Error messages go on the error list and are handled with the check-errors tag.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attributeGroup ref="attlist.call-bsh"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.call-bsh">
        <xs:attribute type="xs:string" name="resource">
            <xs:annotation>
                <xs:documentation>
                    Name of a properties file on the classpath.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of the list in the method environment to check for error messages.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="call-simple-method" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                The call-simple-method tag calls another simple-method in the same context as the current one.
                In other words the called simple-method will have the same environment as the calling simple-method,
                including all environment fields, and either the event or service objects that the calling simple-method was called with.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.call-simple-method"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.call-simple-method">
        <xs:attribute type="xs:string" name="xml-resource">
            <xs:annotation>
                <xs:documentation>
                    The full path and filename on the classpath of the XML file which contains an external simple-method to execute.
                    This is only required if a simple-method in a different file is desired.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="method-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the simple-method to execute in the specified xml-resource,
                    or in the current XML file if no xml-resource is specified.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- Operations to call Java methods and create Java objects -->
    <xs:element name="call-object-method" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                Calls a method on an existing object that exists in a field in the environment or in a map in the environment.

                The string and field sub-elements are passed to the method as arguments in the order they are specified.
                If the sub-elements do not match the method arguments an error will be returned.

                The return value will be put in the named field if an value is returned and
                if a field and optionally a map name are specified.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="string">
                    <xs:annotation>
                        <xs:documentation>
                            Used to specify an inline String argument to the method call.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="field"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.call-object-method"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.call-object-method">
        <xs:attribute type="xs:string" name="obj-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the field the object is in that has the method to be called.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="method-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method to call on the given object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="ret-field">
            <xs:annotation>
                <xs:documentation>
                    The name of the field to put the result in.
                    If not specified any return value will be ignored.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="call-class-method" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                Calls a static method on a class.

                The string and field sub-elements are passed to the method as arguments in the order they are specified.
                If the sub-elements do not match the method arguments an error will be returned.

                The return value will be put in the named field if an value is returned and if a
                field and optionally a map name are specified.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="string">
                    <xs:annotation>
                        <xs:documentation>
                            Used to specify an inline String argument to the method call.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="field">
                    <xs:annotation>
                        <xs:documentation>
                            Used to specify a field to be passed as an argument to the constructor method.
                            The field can be in a map in the environment or if no map-name is specified then
                            the field will come directly from the environment.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:choice>
            <xs:attributeGroup ref="attlist.call-class-method"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.call-class-method">
        <xs:attribute type="xs:string" name="class-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the class to call the static method on.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="method-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the static method to call on the given class.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="ret-field">
            <xs:annotation>
                <xs:documentation>
                    The name of the field to put the result in. If not specified any return value will be ignored.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="create-object" substitutionGroup="CallOperations">
        <xs:annotation>
            <xs:documentation>
                Creates an object of the given class and if the field attribute is specified saves it in that field.
                The string and field sub-elements are passed to the constructor method as arguments in the order they are specified.
                If the sub-elements do not match the constructor method arguments an error will be returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="field">
                    <xs:annotation>
                        <xs:documentation>
                            Used to specify a field to be passed as an argument to the constructor method.
                            The field can be in a map in the environment or if no map-name is specified then
                            the field will come directly from the environment.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="string">
                    <xs:annotation>
                        <xs:documentation>
                            Used to specify an inline String argument to the method call.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:choice>
            <xs:attributeGroup ref="attlist.create-object"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.create-object">
        <xs:attribute type="xs:string" name="class-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the class to construct an object of.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="field">
            <xs:annotation>
                <xs:documentation>
                    The name of a field to put the new object in.
                    If not specified the object will be created but ignored after that.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- Operations to copy map fields in the current env to context specific containers -->
    <!-- Event specific operations -->
    <xs:element name="field-to-request" substitutionGroup="EventOperations">
        <xs:annotation>
            <xs:documentation>
                The field-to-request tag copies a field from a map to the specified servlet request attribute.
                The tag is only used when the simple-method is called as an event, it is ignored otherwise.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.field-to-request"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.field-to-request">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The context name of the field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="request-name">
            <xs:annotation><xs:documentation>The name of the request attribute to use. Defaults to the value of field attribute.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="field-to-session" substitutionGroup="EventOperations">
        <xs:annotation>
            <xs:documentation>
                The field-to-session tag copies a field from a map to the specified servlet session attribute.
                The tag is only used when the simple-method is called as an event, it is ignored otherwise.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.field-to-session"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.field-to-session">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The context name of the field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="session-name">
            <xs:annotation><xs:documentation>The name of the session attribute to use. Defaults to the value of field attribute.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="request-to-field" substitutionGroup="EventOperations">
        <xs:annotation>
            <xs:documentation>
                The request-to-field tag copies an attribute from the servlet request to a field of a map in the method environment.
                The tag is only used when the simple-method is called as an event, it is ignored otherwise (except the default value, if specified).
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.request-to-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.request-to-field">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The context name of the field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default">
            <xs:annotation>
                <xs:documentation>
                    A default value to use if the request attribute is null or is a String and is empty.
                    This will also be used when NOT running as an event.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="request-name">
            <xs:annotation><xs:documentation>The name of the request attribute to use. Defaults to the value of the field attribute.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="request-parameters-to-list" substitutionGroup="EventOperations">
        <xs:annotation>
            <xs:documentation>
                The request-parameters-to-list tag appends a request parameter values from the servlet request to the specified list.
                The tag is only used when the simple-method is called as an event, it is ignored otherwise.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.request-parameters-to-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.request-parameters-to-list">
        <xs:attribute type="xs:string" name="request-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the request parameter values to use.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="list-name">
            <xs:annotation>
                <xs:documentation>
                    The name of the list in the method environment that the request parameter values will be appended to.
                    (default: request-name)
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="session-to-field" substitutionGroup="EventOperations">
        <xs:annotation>
            <xs:documentation>
                The session-to-field tag copies an attribute from the servlet session to a field of a map in the method environment.
                The tag is only used when the simple-method is called as an event, it is ignored otherwise (except the default value, if specified).
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.session-to-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.session-to-field">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The name (key) of the map field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default">
            <xs:annotation>
                <xs:documentation>
                    A default value to use if the session attribute is null or is a String and is empty.
                    This will also be used when NOT running as an event.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="session-name">
            <xs:annotation>
                <xs:documentation>
                    The name of the session attribute to use. Defaults to the value of field attribute.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="webapp-property-to-field" substitutionGroup="EventOperations">
        <xs:annotation>
            <xs:documentation>
                The webapp-property-to-field tag copies a property value from a properties file in a ServletContext resource to a field.
                The tag is only used when the simple-method is called as an event, it is ignored otherwise (except the default value, if specified).
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.webapp-property-to-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.webapp-property-to-field">
        <xs:attribute type="xs:string" name="resource" use="required">
            <xs:annotation>
                <xs:documentation>
                    The resource location of the properties file inside the webapp,
                    and relative to the root of the webapp (can be inside a war file).
                    An example of this is "/WEB-INF/myprops.properties".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="property" use="required">
            <xs:annotation><xs:documentation>The property whose value will be put in the field.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default">
            <xs:annotation>
                <xs:documentation>
                    A default value to use if the property value is null or empty.
                    This will also be used when NOT running as an event.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The name (key) of the field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="session-name">
            <xs:annotation><xs:documentation>The name of the session attribute to use. Defaults to the value of field attribute</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- Service specific operations -->
    <xs:element name="field-to-result" substitutionGroup="ServiceOperations">
        <xs:annotation>
            <xs:documentation>
                The field-to-result tag copies a field from a map to the specified service result field.
                The tag is only used when the simple-method is called as a service, it is ignored otherwise.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.field-to-result"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.field-to-result">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The name (key) of the map field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="result-name">
            <xs:annotation><xs:documentation>The name of the result Map name/key to use. Defaults to the value of field attribute.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- Environment specific operations -->
    <xs:element name="map-to-map" substitutionGroup="EnvOperations">
        <xs:annotation>
            <xs:documentation>
                The map-to-map tag copies all fields from one map to another map.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.map-to-map"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.map-to-map">
        <xs:attribute type="xs:string" name="map" use="required">
            <xs:annotation><xs:documentation>The name of the map in the method environment the fields will come from.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="to-map">
            <xs:annotation>
                <xs:documentation>
                    The name of the map in the method environment the fields will go to.
                    If empty the fields will be copied to the environment.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="field-to-list" substitutionGroup="EnvOperations">
        <xs:annotation><xs:documentation>The field-to-list tag appends a field to the specified list.</xs:documentation></xs:annotation>
        <xs:complexType><xs:attributeGroup ref="attlist.field-to-list"/></xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.field-to-list">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The name (key) of the map field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation><xs:documentation>The name of the list in the method environment that the object will be appended to.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="list-to-list" substitutionGroup="EnvOperations">
        <xs:annotation><xs:documentation>Copy a list to another list.</xs:documentation></xs:annotation>
        <xs:complexType><xs:attributeGroup ref="attlist.list-to-list"/></xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.list-to-list">
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation><xs:documentation>Name of the list to copy from</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="to-list" use="required">
            <xs:annotation><xs:documentation>Name of the list to copy to.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="order-map-list" substitutionGroup="EnvOperations">
        <xs:annotation><xs:documentation>Sort a List containing Maps: order by fields names given in order-by sub-element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence><xs:element maxOccurs="unbounded" ref="order-by"/></xs:sequence>
            <xs:attributeGroup ref="attlist.order-map-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.order-map-list">
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation><xs:documentation>Name of the list to be sorted.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="set" substitutionGroup="EnvOperations">
        <xs:annotation>
            <xs:documentation>
                Move a value from one field to another field.
                You can also take a value, just a string constant or a string
                that is made up of a mixture of constant and flexible
                string expansion variables using the ${} syntax, that will be
                put in the field.

                You can also specify a default value in the case that the
                value evaluates to an empty string or the from-field is
                null or empty. Then the default-value will be used.

                Again you can use the flexible string expander here, the
                ${} syntax and such. It can also do a type conversion,
                so going from whatever type the source data is in,
                which would be a string value or whatever the variable
                type is for a from field, it can convert that to any of
                these types before setting it in the target field.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.set"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.set">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the field to copy value to.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="from-field">
            <xs:annotation>
                <xs:documentation>
                    Name of the field to copy value from.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="value">
            <xs:annotation>
                <xs:documentation>
                    Simple value to copy in field.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default-value">
            <xs:annotation>
                <xs:documentation>
                    Default value to copy in field if value evaluates to an empty string or the from-field is null or empty.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type">
            <xs:annotation>
                <xs:documentation>
                    Type to convert to. NewList will create a new List, NewMap will create a new Map.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="PlainString"/>
                    <xs:enumeration value="String"/>
                    <xs:enumeration value="BigDecimal"/>
                    <xs:enumeration value="Double"/>
                    <xs:enumeration value="Float"/>
                    <xs:enumeration value="List"/>
                    <xs:enumeration value="Long"/>
                    <xs:enumeration value="Integer"/>
                    <xs:enumeration value="Date"/>
                    <xs:enumeration value="Time"/>
                    <xs:enumeration value="Timestamp"/>
                    <xs:enumeration value="Boolean"/>
                    <xs:enumeration value="Object"/>
                    <xs:enumeration value="NewList"/>
                    <xs:enumeration value="NewMap"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="set-if-null" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not to set fields that are null or empty.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="set-if-empty" default="true">
            <xs:annotation>
                <xs:documentation>
                    If the source value, either from a value or from a field, is empty, and
                    empty-string an empty list or a null value.
                    In this case it's set to true.

                    If you don't want to set, if you want it to
                    leave the target field alone when the source is empty,
                    then you need to set this to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="string-append" substitutionGroup="EnvOperations">
        <xs:annotation>
            <xs:documentation>
                NOTE: the prefix and suffix will only be used IFF the current string and the string to be appended are both not empty.

                So if the field does not exist then it will create a new field with this string value.
                If it does exist then it will append this string value to the end.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.string-append"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.string-append">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The field that you want string-append to operate on.
                    This is the target field where the value will be put, and this is the string to append to that field.

                    So if the field does not exist then it will create a new field with this string value.
                    If it does exist then it will append this string value to the end.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="string" use="required">
            <xs:annotation>
                <xs:documentation>
                    The string to append to the field named in field-name.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="arg-list">
            <xs:annotation>
                <xs:documentation>
                    arg-list-name is used to insert values from a list into
                    the string using the object in the standard Java library
                    that does this sort of string expression with a { } brackets
                    and a number, no dollar sign.

                    This pattern of the arg-list-name with the prefix and
                    suffix is something form the early days which is still
                    supported, but the best thing to do here is just use the
                    flexible string expander which is far more flexible and
                    powerful. So you can have the prefix variables to expand
                    and everything all mixed into one string.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="prefix">
            <xs:annotation>
                <xs:documentation>
                    Used in conjunction with arg-list-name.
                    String that will be prepended to the string,
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="suffix">
            <xs:annotation>
                <xs:documentation>
                    Used in conjunction with arg-list-name.
                    String that will be appended to the string,
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="string-to-list" substitutionGroup="EnvOperations">
        <xs:annotation>
            <xs:documentation>
                Take a string literally that can also have a flexible string expander and such in it,
                and it will add it to a list.

                Note that you can have an arg-listname for using the standard
                Java style argument list where you have in the source
                string numbers inside of { } brackets that represent the
                number the index in the argument list to insert at that point.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.string-to-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.string-to-list">
        <xs:attribute type="xs:string" name="string" use="required">
            <xs:annotation>
                <xs:documentation>
                    String to add to the list named in list-name.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    List to add string to.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="arg-list">
            <xs:annotation>
                <xs:documentation>
                    arg-list-name is used to insert values from a list into
                    the string using the object in the standard Java library
                    that does this sort of string expresison with a { } brackets
                    and a number, no dollar sign.

                    This pattern of the arg-list-name with the prefix and
                    suffix is something form the early days which is still
                    supported, but the best thing to do here is just use the
                    flexible string expander which is far more flexible and
                    powerful. So you can have the prefix variables to expand
                    and everything all mixed into one string.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="message-field">
            <xs:annotation>
                <xs:documentation>
                    To insert a message above a field (used in conjunction with @fieldErrors FTL macro)
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="to-string" substitutionGroup="EnvOperations">
        <xs:annotation>
            <xs:documentation>
                The to-string tag converts the Object in the specified field to a String, putting the string in the same field.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.to-string"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.to-string">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name (key) of the map field to use.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="format">
            <xs:annotation>
                <xs:documentation>
                    Format based on the type of the object (date,number, etc.).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="numeric-padding">
            <xs:annotation>
                <xs:documentation>
                    Padding to use if a numeric object is used.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="clear-field" substitutionGroup="EnvOperations">
        <xs:annotation>
            <xs:documentation>
                Sets the value of the specified field to null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.clear-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.clear-field">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name (key) of the map field to use.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="first-from-list" substitutionGroup="EnvOperations">
        <xs:annotation>
            <xs:documentation>
                The first-from-list tag will get the first entry from the given list and put it in the environment field with the given entry-name.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.first-from-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.first-from-list">
        <xs:attribute type="xs:string" name="entry" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that will contain the first entry in the list.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the list to get the first entry from.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
        These operations are used to interact with a data source through the entity
        engine and facilitate related operations.
    -->
    <xs:element name="transaction-begin" substitutionGroup="EntityTxOperations">
        <xs:annotation>
            <xs:documentation>
                The transaction-begin tag will begin a transaction if one is not already in place.
                If a transaction is begun the environment field named as the began-transaction-name will be set to true, otherwise it will be set to false.

                Note that unless the simple-method is flagged to not use a transaction all simple-methods will be inside a transaction.
                The same is true for service calls through the Service Engine.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.transaction-begin"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.transaction-begin">
        <xs:attribute type="xs:string" name="began-transaction-name" default="beganTransaction">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains a Boolean specifying whether or not a transaction was begun in the current transaction demarcation.
                    Defaults to "beganTransaction".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="transaction-commit" substitutionGroup="EntityTxOperations">
        <xs:annotation>
            <xs:documentation>
                The transaction-commit tag will commit a transaction if a transaction was begun in the current demarcation context as represented by the environment field named as the began-transaction-name.
                If the Boolean in that field is false no commit will be done.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.transaction-commit"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.transaction-commit">
        <xs:attribute type="xs:string" name="began-transaction-name" default="beganTransaction">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains a Boolean specifying whether or not a transaction was begun in the current transaction demarcation.
                    Defaults to "beganTransaction".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="transaction-rollback" substitutionGroup="EntityTxOperations">
        <xs:annotation>
            <xs:documentation>
                The transaction-rollback tag will rollback a transaction if a transaction was begun in the current demarcation context as represented by the environment field named as the began-transaction-name.
                If the Boolean in that field is false a set rollback only will operation will be done instead of rollback which will force the transaction to rollback regardless of which method or object is responsible for beginning and ending the transaction.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.transaction-rollback"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.transaction-rollback">
        <xs:attribute type="xs:string" name="began-transaction-name" default="beganTransaction">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains a Boolean specifying whether or not a transaction was begun in the current transaction demarcation.
                    Defaults to "beganTransaction".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="sequenced-id" substitutionGroup="EntityMiscOperations">
        <xs:annotation>
            <xs:documentation>
                The sequenced-id tag gets a sequenced ID from the Entity Engine (through the delegator) and puts it in the specified method environment field.
                The object will be a java.lang.Long, but can of course be converted to a String.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.sequenced-id"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.sequenced-id">
        <xs:attribute type="xs:string" name="sequence-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the sequence to pass to the delegator.
                    The same name must always be used for sequenced IDs that will be used for a certain entity field otherwise non-unique keys may result.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field the sequenced ID will be put in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="get-long-only" default="false">
            <xs:annotation>
                <xs:documentation>
                    Get a numerical long value and put it there, so it does not do that by default.
                    By default getlong-only is false. If you want it to just get a long number
                    then you can set that to true. That's in there for supporting lower level functionality,
                    but that's not the typical pattern used in OFBiz as we do use strings for sequencing.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="stagger-max">
            <xs:annotation>
                <xs:documentation>
                    By default this is one. But if you want to have sequenced Ids that are staggered, instead
                    of consecutive, then you can set this to something like twenty. And then it will do a random staggering for
                    each sequenced id; instead of picking the next value all the time it will pick something between the next value
                    and twenty away from the next value, if stagger-max is set to twenty.
                    So that can be used to make the sequenced Ids more difficult to guess.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="make-next-seq-id" substitutionGroup="EntityMiscOperations">
        <xs:annotation>
            <xs:documentation>
                sequenced-id is the primary key sequencer.
                Make-next-seq-id is the secondary key sequencer. So
                this would be something like an orderId for example,
                where we're sequencing an orderId automatically. And
                this would be something like an orderItemSequenceId,
                where we have a sub-sequence that varies for order
                item records related back to an orderHeader. So all of
                them will have the same orderId.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.make-next-seq-id"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.make-next-seq-id">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    Specify the name of the entity for a sequenced-id preparing the primarySequencedId.
                    The name of the entity is typically what we use for the sequenced name, but you can use anything
                    you want if you want to have different sets of sequences.

                    The risk of course of many different sets of sequences
                    for the same entity is unless you somehow prefix or
                    suffix the value, you could have a key conflict. So we
                    just use the entity name for these primary sequences.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="seq-field-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The field that will have the sub-sequenced value.
                    We use the seqId suffix on the field names in the OFBiz
                    data model to denote that that field is a secondary sequenced ID
                    and should therefore be maintained for this sort of operation.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="numeric-padding" default="5">
            <xs:annotation>
                <xs:documentation>
                    Since these are eventually strings we do numeric-padding so that the sort is consistent,
                    By default we pad it with five positions.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="increment-by" default="1">
            <xs:annotation>
                <xs:documentation>
                    Default to 1.
                    If you want to leave some space in the sub-sequence you
                    can use a greater increment.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>

    <xs:element name="entity-data" substitutionGroup="EntityMiscOperations">
        <xs:annotation>
            <xs:documentation>
                Specify the location of an XML file that should be in the same format as any
                of the entity engine XML files, or the entity engine transformed
                XML files. And what this will do is either load or
                assert that file depending on the mode.

                If it finds the record but any of the fields are different,
                this is in the assert mode still, it will report any field
                that's different in a message on the error list. So that's
                basically what you can in essence assert, that a certain
                set of data exists in the database.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.entity-data"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.entity-data">
        <xs:attribute type="xs:string" name="location" use="required">
            <xs:annotation>
                <xs:documentation>
                    Specify the location of an XML file to load in database or verify in assert mode.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="delegator-name" use="optional">
            <xs:annotation>
                <xs:documentation>
                    Overrides the delegator or default context by specifying a delegator-name.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:integer" name="timeout" default="-1">
            <xs:annotation>
                <xs:documentation>
                    Override the timeout to start a new transaction and load the data with a longer timeout.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of the list in the method environment to check for error messages.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mode" default="load">
            <xs:annotation>
                <xs:documentation>
                    "load" or "assert". Default to "load".
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="load">
                        <xs:annotation>
                            <xs:documentation>
                                Load the file into the database.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="assert">
                        <xs:annotation>
                            <xs:documentation>
                                Go through each row in the file, each record, and it
                                will look that up by primary key. If it does not find it, it'll
                                add a message to the error list about not having found it.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="find-by-primary-key" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                The find-by-primary-key tag uses the delegator to find an entity value by its primary key.
                The resulting GenericValue object will be placed in the method environment using the specified value-field.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.find-by-primary-key"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.find-by-primary-key">
        <xs:attribute type="xs:string" name="entity-name" use="optional">
            <xs:annotation>
                <xs:documentation>
                    The name of the entity to find an instance of.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that will contain the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="use-cache" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not the delegator's cache should be searched before going to the database.
                    This results in much faster retrieval times, but can return stale data that is not the most current in the database.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="fields-to-select-list">
            <xs:annotation>
                <xs:documentation>
                    List containing name of fields to select, if empty defaults to all entity fields.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="delegator-name">
            <xs:annotation>
                <xs:documentation>
                    By default this operation is done using the delegator that is part of the simple-method calling context.
                    This allows you to override the default delegator by naming an alternate delegator.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="find-by-and" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                The find-by-and tag uses the delegator to find entity values by anding the fields passed in the map.
                The resulting GenericValue objects will be placed in the method environment using the specified list-name.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.find-by-and"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.find-by-and">
        <xs:attribute type="xs:string" name="entity-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the entity to find instances of.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="order-by-list">
            <xs:annotation>
                <xs:documentation>
                    This will be a list sitting in the context that has string entries in it for each field that you want it to order by/
                    Each field in the list, or each entry in the list, will just be a string with a field name.
                    It can be preceded by a plus or a minus to specify an ascending or descending sort for that.
                    The default is ascending sort, so you just put a minus in front of the field-name if you want it to be descending.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="delegator-name">
            <xs:annotation>
                <xs:documentation>
                    By default this operation is done using the delegator that is part of the simple-method calling context.
                    This allows you to override the default delegator by naming an alternate delegator.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="use-cache" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not the delegator's cache should be searched before going to the database.
                    This results in much faster retrieval times, but can return stale data that is not the most current in the database.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="use-iterator" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not to use the EntityListIterator when doing the query.
                    This is much more efficient for large data sets because the results are read incrementaly instead of all at once.
                    Note that when using this the use-cache setting will be ignored.
                    Also note that an EntityListIterator must be closed when you are finished, but this is done automatically by the iterate operation.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that will contain the list of GenericValue objects.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="entity-one" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                Does a find-by-primarykey, always returns a single generic value object if it's found, otherwise returns null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="field-map">
                    <xs:annotation>
                        <xs:documentation>
                            Specify where to find primary key fields if you set auto-field-map to false.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="select-field">
                    <xs:annotation>
                        <xs:documentation>
                            Specify fields to select, otherwise all fields will be selected.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.entity-one"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.entity-one">
        <xs:attribute name="entity-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the entity to query on.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value-field" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the variable to put result record in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="use-cache" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not the delegator's cache should be searched before going to the database.
                    This results in much faster retrieval times, but can return stale data that is not the most current in the database.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="auto-field-map" default="true">
            <xs:annotation>
                <xs:documentation>
                    Looks for all primary key field names in  the current context as well as in the parameters map or not.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="entity-and" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                Does a find-by-and, returns a list of GenericValues if any are found, otherwise returns an empty list.
                Uses name/value pairs, that will be used for the query and will all be "anded" together.

                The result-set-type by default is scroll which is flexible so you can go forward.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element maxOccurs="unbounded" ref="field-map"/>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="select-field">
                    <xs:annotation><xs:documentation>Specify fields to select, otherwise all fields will be selected.</xs:documentation></xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="order-by">
                    <xs:annotation><xs:documentation>Defines fields to order list by.</xs:documentation></xs:annotation>
                </xs:element>
                <xs:choice minOccurs="0">
                    <xs:element ref="limit-range"/>
                    <xs:element ref="limit-view"/>
                    <xs:element ref="use-iterator"/>
                </xs:choice>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.entity-and"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.entity-and">
        <xs:attribute name="entity-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of entity to search in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="use-cache" type="xs:string" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not the delegator's cache should be searched before going to the database.
                    This results in much faster retrieval times, but can return stale data that is not the most current in the database.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="filter-by-date" default="false">
            <xs:annotation>
                <xs:documentation>
                    Look for from-date and through-date fields in the list of results coming back
                    and filters by the current date and time if set to true.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                    <xs:enumeration value="by-name"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="list" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the list where to put results.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="entity-condition" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                Like entity-and returns a list of Generic values if any are found, otherwise returns an empty list.
                Uses any of condition-expression, condition-list and condition-object.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:choice minOccurs="0">
                    <xs:element ref="condition-expr"/>
                    <xs:element ref="condition-list"/>
                    <xs:element ref="condition-object"/>
                </xs:choice>
                <xs:element minOccurs="0" ref="having-condition-list"/>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="select-field">
                    <xs:annotation>
                        <xs:documentation>
                            Specify fields to select, otherwise all fields will be selected.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="order-by"/>
                <xs:choice minOccurs="0">
                    <xs:element ref="limit-range"/>
                    <xs:element ref="limit-view"/>
                    <xs:element ref="use-iterator"/>
                </xs:choice>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.entity-condition"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.entity-condition">
        <xs:attribute name="entity-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of entity to search in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="use-cache" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not the delegator's cache should be searched before going to the database.
                    This results in much faster retrieval times, but can return stale data that is not the most current in the database.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="filter-by-date" default="false">
            <xs:annotation>
                <xs:documentation>
                    Look for from date and through date fields in the list of results coming back
                    and filters by the current date and time if set to true.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                    <xs:enumeration value="by-name"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="distinct" default="false">
            <xs:annotation>
                <xs:documentation>
                    Filter the results making sure that all of them are unique.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="delegator-name" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    Name of a delegator to use.
                    By default uses the delegator associated with that instance of the service engine.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="list" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the list where to put results.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="condition-list">
        <xs:annotation>
            <xs:documentation>
                A condition-list is a list of conditions that are combined with either and or or.
                The default is and.

                You can have condition-lists under condition-list, for building fairly complex condition trees,
                and you can also drop in condition-objects at any point.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="condition-expr"/>
                <xs:element ref="condition-list"/>
                <xs:element ref="condition-object"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.condition-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.condition-list">
        <xs:attribute name="combine" default="and">
            <xs:annotation>
                <xs:documentation>
                    "or" or "and", defaults to and.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="and"/>
                    <xs:enumeration value="or"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="having-condition-list">
        <xs:annotation>
            <xs:documentation>
                Similar to condition-list but relates to SQL grouping : having-condition runs after the grouping.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="condition-expr"/>
                <xs:element ref="condition-list"/>
                <xs:element ref="condition-object"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.having-condition-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.having-condition-list">
        <xs:attribute name="combine" default="and">
            <xs:annotation>
                <xs:documentation>
                    "or" or "and", defaults to and.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="and"/>
                    <xs:enumeration value="or"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="condition-expr">
        <xs:annotation>
            <xs:documentation>
                Basically combines a field, an SQL operator and a variable or a value.
                The variable is actually a field in the context : env-name.
                There are some options to ignore the condition if the env-name or value is empty or null.
                Or to ignore case.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.condition-expr"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.condition-expr">
        <xs:attribute name="field-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the field to apply operator on, combined with env-name or value.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="operator" default="equals">
            <xs:annotation>
                <xs:documentation>
                    Operator to apply to field-name and env-name or value.
                    If you use the between then the env-name must point to
                    a collection that has two entries in it. With in you may specify several entries.
                    If you use like, then it's just a single thing, as will all of the other ones;
                    less, greater, less-equals, greater-equals, equals, not equals.
                    Defaults to equals.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="less"/>
                    <xs:enumeration value="greater"/>
                    <xs:enumeration value="less-equals"/>
                    <xs:enumeration value="greater-equals"/>
                    <xs:enumeration value="equals"/>
                    <xs:enumeration value="not-equals"/>
                    <xs:enumeration value="in"/>
                    <xs:enumeration value="not-in"/>
                    <xs:enumeration value="between"/>
                    <xs:enumeration value="like"/>
                    <xs:enumeration value="not-like"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="from-field" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    Name of field (variable) to apply operator on, along with field-name.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    Value to apply operator on, combined with field-name.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignore-if-null" default="false">
            <xs:annotation>
                <xs:documentation>
                    Ignore the condition if the env-name or value is null.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="ignore-if-empty" default="false">
            <xs:annotation>
                <xs:documentation>
                    Ignore the condition if the env-name or value is empty.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="ignore-case" default="false">
            <xs:annotation>
                <xs:documentation>
                    Ignore case when using operator if the env-name or value is empty.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="ignore" default="false">
            <xs:annotation>
                <xs:documentation>
                    Ignore the condition if flag is true.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="condition-object">
        <xs:annotation>
            <xs:documentation>
                An instance of the entity-condition, or an object that implements the entity-condition interface.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.condition-object"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.condition-object">
        <xs:attribute name="field" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Field in the current context where that condition object is that implements the entity condition interface.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="select-field">
        <xs:complexType>
            <xs:attributeGroup ref="attlist.select-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.select-field">
        <xs:attribute name="field-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of field to select.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="order-by">
        <xs:annotation>
            <xs:documentation>
                Defines fields to order list by.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.order-by"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.order-by">
        <xs:attribute name="field-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of field to order list by.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="limit-range">
        <xs:annotation>
            <xs:documentation>
                Specify a start, value, and a number of results to include.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.limit-range"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.limit-range">
        <xs:attribute name="start" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Should resolve into a non-negative integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="size" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Should resolve into a non-negative integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="limit-view">
        <xs:annotation>
            <xs:documentation>
                Specify a view-index, and a view-size of elements to view.
                Start at view-index - 1 times of view-size with origin 0.
                Example : view-index=3 and view-size=10 gives elements 21 to 30.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.limit-view"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.limit-view">
        <xs:attribute name="view-index" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Index of elements to view, depends on view-size.
                    Should resolve into a non-negative integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="view-size" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Number of elements to view.
                    Should resolve into a positive integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="use-iterator">
        <xs:annotation>
            <xs:documentation>
                Specifies whether or not to use the EntityListIterator when doing the query.
                This is much more efficient for large data sets because the results are read incrementaly instead of all at once.
                Note that when using this the use-cache setting will be ignored.
                Also note that an EntityListIterator must be closed when you are finished, but this is done automatically by the iterate operation.
                Must be "true" or "false", defaults to "false".
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>
    <xs:element name="field-map">
    <xs:complexType>
            <xs:attributeGroup ref="attlist.field-map"/>
        </xs:complexType>
    </xs:element>
    <xs:annotation>
        <xs:documentation>
            A name/value pair.
        </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup name="attlist.field-map">
        <xs:attribute type="xs:string" name="field-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the field.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="from-field">
            <xs:annotation>
                <xs:documentation>
                    Name of the variable in the context.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="value">
            <xs:annotation>
                <xs:documentation>
                    Literal or flexible string using ${} syntax.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="entity-count" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                Returns a long presenting the number of results found matching the specified condition.
                The entity-count is very  similar to the entity-condition.

                Specify the entity-name, optionally the delgator-name if you want to override that,
                and then the name of the variable to put the count in.

                You can do the same condition-expr (condition expression) or condition-list which can have condition-expr
                and other condition-lists underneath it for a tree of conditions that can be arbitrarily complex.
                You can also use the have-in-condition-list, this is the same as on the entity-condition.
                What this will do basically is, rather than doing a query and getting the results back,
                it will just count the results and put that number in the context in the variable named by the count-name.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:choice>
                    <xs:element ref="condition-expr"/>
                    <xs:element ref="condition-list"/>
                    <xs:element ref="condition-object"/>
                </xs:choice>
                <xs:element minOccurs="0" ref="having-condition-list"/>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.entity-count"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.entity-count">
        <xs:attribute name="entity-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of entity to search in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="delegator-name" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    Name of a delegator to use.
                    By default uses the delegator associated with that instance of the service engine.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="count-field" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the field (variable) to put result of the count in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="get-related-one" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                If you have a generic value object sitting in the context and you want to get a related entity
                following one of the type one relationships in the data model, then you can specify the name of the value
                here, the relation-name, the name of the relationship between the two entities, and the to-value where it
                should put the result, and you can tell it to use-cache or not, by default it doesn't.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.get-related-one"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.get-related-one">
        <xs:attribute name="value-field" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a generic value sitting in the context from where you want to get a related-one generic value.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="relation-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the one-relation to use to relate generic value in value-field to generic value in to-value.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="use-cache" type="xs:string" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not the delegator's cache should be searched before going to the database.
                    This results in much faster retrieval times, but can return stale data that is not the most current in the database.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="to-value-field" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a generic value where to put the result.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="get-related" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                Get-related is just like get-related-one,
                except that instead of getting a single value back to put in the to-value,
                it gets a full list back.

                You start with the the value object, specify the name of the relationship.
                You can specify the name of a map that will restrain the query further,
                beyond the field mappings and their relationship.

                You can also specify how you want to order it.

                Use-cache true or false, list-name for the output.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.get-related"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.get-related">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a generic value sitting in the context from where you want to get a related generic value.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="relation-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the relation to use to relate generic value in value-field to generic value in to-value.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map">
            <xs:annotation>
                <xs:documentation>
                    Name of a map that will restrain the query further,
                    beyond the field mappings and their relationship.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="order-by-list">
            <xs:annotation>
                <xs:documentation>
                    This will be a list sitting in the context that has string entries in it for each field that you want it to order by/
                    Each field in the list, or each entry in the list, will just be a string with a field name.
                    It can be preceded by a plus or a minus to specify an ascending or descending sort for that.
                    The default is ascending sort, so you just put a minus in front of the field-name if you want it to be descending.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="use-cache" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not the delegator's cache should be searched before going to the database.
                    This results in much faster retrieval times, but can return stale data that is not the most current in the database.
                    Must be "true" or "false", defaults to "false".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a list where to put the result in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="order-value-list" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                Order-value-list does not actually do anything with the database.
                It takes an exiting list that has been returned and sorts it.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.order-value-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.order-value-list">
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the list of generic value objects that we want to sort.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="to-list">
            <xs:annotation>
                <xs:documentation>
                    Name of the output list. If it is empty, as it is optional, it will simply use the list-name.
                    In other words it will take the ordered list and put it over top of the resource list.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="order-by-list" use="required">
            <xs:annotation>
                <xs:documentation>
                    This will be a list sitting in the context that has string entries in it for each field that you want it to order by.
                    Each field in the list, or each entry in the list, will just be a string with a field name.
                    It can be preceded by a plus or a minus to specify an ascending or descending sort for that.
                    The default is ascending sort, so you just put a minus in front of the field-name if you want it to be descending.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="filter-list-by-and" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                The filter-list-by-and tag filters the given list by the fields in the specified map.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.filter-list-by-and"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.filter-list-by-and">
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the list of GenericValue objects.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="to-list">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field the filtered list will be put into.
                    Defaults to the value of the list-name attribute (ie goes to the same place it came from, replacing the old list).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                    If no map is used this will just make a copy of the list.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="filter-list-by-date" substitutionGroup="EntityFindOperations">
        <xs:annotation>
            <xs:documentation>
                The filter-list-by-date tag filters the given list by the valid date using the from and thru dates in each value object.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.filter-list-by-date"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.filter-list-by-date">
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the list of GenericValue objects.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="to-list">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field the filtered list will be put into.
                    Defaults to the value of the list-name attribute (ie goes to the same place it came from, replacing the old list).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="valid-date">
            <xs:annotation>
                <xs:documentation>
                    The name of a field in the method environment date to filter by.
                    Defaults to now.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="from-field-name" default="fromDate">
            <xs:annotation>
                <xs:documentation>
                    The name of the GenericValue field to use as the beginning effective date.
                    Defaults to fromDate.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="thru-field-name" default="thruDate">
            <xs:annotation>
                <xs:documentation>
                    The name of the GenericValue field to use as the ending effective date.
                    Defaults to thruDate.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="all-same" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not all GenericValue objects in the list are of the same entity.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="make-value" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                The make-value tag uses the delegator to construct an entity value.
                The resulting value will not necessarily exist in the database, but will simply be assembled using the entity-name and fields map.
                The resulting GenericValue object will be placed in the method environment using the specified value-field.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.make-value"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.make-value">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="entity-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the entity to construct an instance of.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="clone-value" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                The clone-value tag make a copy of the value in the method environment field specified by value-field.
                The resulting GenericValue object will be placed in the method environment using the specified new-value-field.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.clone-value"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.clone-value">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="new-value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that will contain the new GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="create-value" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                The create-value tag persists the specified GenericValue object by creating a new instance of the entity in the datasource.
                An error will result if an instance of the entity exists in the datasource with the same primary key.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.create-value"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.create-value">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="or-store" default="false">
            <xs:annotation>
                <xs:documentation>
                    Store value if already exists, defaults to false
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="store-value" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                The store-value tag persists the specified GenericValue object by updating the instance of the entity in the datasource.
                An error will result if an instance of the entity does not exist in the datasource with the same primary key.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.store-value"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.store-value">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="refresh-value" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                Refresh from database the value given in value-field.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.refresh-value"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.refresh-value">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the value to refresh from database.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="remove-value" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                The remove-value tag removes the specified GenericValue object by removing the instance of the entity in the datasource.
                An error will result if an instance of the entity does not exist in the datasource with the same primary key.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.remove-value"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.remove-value">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="remove-related" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                Given a value name and a relationship name,
                follows the relationship and remove all related
                records, whether they be a type one or type many
                relationship.

                For a type one relationship it will remove a
                single record if it exists, and for a type many relationship
                it will remove all the records that are related to it.

                This of course can be dangerous, for example if you
                have a product-type entity and you do a remove-related
                with a certain product type value object here, and the
                relation name product here, it will remove all products
                of that type. This is of more value when you're doing
                something like removing an order or removing a product,
                and you want to remove all related elements before
                removing the product to resolve foreign key issues.

                Usually the best practice for that, for removing a product
                for example, is to do a remove-related on certain
                types of information related to the product, and then try
                to remove the product but not remove all related tables.

                In many cases, if the product has been ordered for example,
                then you do not want to remove the product,
                and so you can do all these remove-relateds.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.remove-related"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.remove-related">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a generic value to remove all related records.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="relation-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a relation to use to remove related records.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="remove-by-and" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                The remove-by-and tag uses the delegator to remove entity values from the datasource and is constrained by anding the fields passed in the map.
                Make sure the map contains something, or all values will be removed.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.remove-by-and"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.remove-by-and">
        <xs:attribute type="xs:string" name="entity-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the entity to remove instances of.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="clear-cache-line" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                Uses the delegator to clear elements from the cache;
                intelligently looks at the map passed to see if it is a byPrimaryKey, and byAnd, or an all.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.clear-cache-line"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.clear-cache-line">
        <xs:attribute type="xs:string" name="entity-name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the entity to clear cache lines of.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                    If the fields in the map form the full primary key the entry will be removed from the byPrimaryKey cache.
                    If the map exists but the fields do not include a full primary key the entry will be removed from the byAnd cache.
                    If no map name is specified the entry will be removed from the all cache.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="clear-entity-caches" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                This is a very simple tag that should be used sparingly because of the performance impact.
                It clears all lines from all Entity Engine caches.
                It has no attributes or sub-elements.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>
    <xs:element name="set-pk-fields" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                Looks for each PK field in the named map and if it exists there it will copy it into the named value object.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.set-pk-fields"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.set-pk-fields">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="set-if-null" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not to set fields that are null or empty.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="set-nonpk-fields" substitutionGroup="EntityValueOperations">
        <xs:annotation>
            <xs:documentation>
                Looks for each non-PK field in the named map and if it exists there it will copy it into the named value object.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.set-nonpk-fields"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.set-nonpk-fields">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map">
            <xs:annotation>
                <xs:documentation>
                    The name of a map in the method environment that will be used for the entity fields.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="set-if-null" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not to set fields that are null or empty.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="store-list" substitutionGroup="EntityListOperations">
        <xs:annotation>
            <xs:documentation>
                The store-list tag uses the delegator to store all entity values in the list.
                This is different than storing a single value in that values in the list will be inserted if it does not exist or updated if it does exist.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.store-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.store-list">
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the list of GenericValue objects.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="remove-list" substitutionGroup="EntityListOperations">
        <xs:annotation>
            <xs:documentation>
                The remove-list tag uses the delegator to remove all entity values in the list.
                For each value in the list if it is a primary key just that entity instance will be removed, but if it is not a full primary key all entity instances will be removed from the datasource that match the constraint of the field map.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.remove-list"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.remove-list">
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the list of GenericValue objects.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="do-cache-clear" default="true">
            <xs:annotation>
                <xs:documentation>
                    Clear the cache, defaults to true
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>

    <!-- =================== CONTROL OPERATIONS =================== -->
    <xs:element name="iterate" substitutionGroup="ControlOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the iterate tag will be executed for each of the entries in the list,
                and will make the current entry available in the method environment by the entry-name specified.
                This tag can contain any of the simple-method operations, including the conditional/if operations.

                Any simple-method operation can be nested under the iterate tag.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
            <xs:attributeGroup ref="attlist.iterate"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.iterate">
        <xs:attribute type="xs:string" name="entry" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that will contain each entry as we iterate through the list.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="list" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the list to iterate over.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="iterate-map" substitutionGroup="ControlOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the iterate-map tag will be executed for each of the entries in the map.
                It will run all of the operations underneath the iterate-map-element for each of the entries in the given map,
                setting the key for that entry and the key name variable, and the value for that entry and the value variable.

                This tag can contain any of the simple-method operations, including the conditional/if operations.

                Any simple-method operation can be nested under the iterate-map tag.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
            <xs:attributeGroup ref="attlist.iterate-map"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.iterate-map">
        <xs:attribute type="xs:string" name="key" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the variable to put the key.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="value" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the variable to put the value in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="map" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the map to use.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="loop" substitutionGroup="ControlOperations">
        <xs:annotation>
            <xs:documentation>
                Loop, rather than iterating over some sort of a structure,
                will simply loop a certain number of times. The
                number of times to loop is specified in the count attribute,
                and it will put the current count in the field attribute,
                or in the variable named by the field attribute. So if you
                want to loop ten times you say count=ten, and
                field=count for example. First time through count will
                be zero; last time through count will be nine.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
            <xs:attributeGroup ref="attlist.loop"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.loop">
        <xs:attribute type="xs:string" name="count" use="required">
            <xs:annotation>
                <xs:documentation>
                    Number of times to loop.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="field" use="optional">
            <xs:annotation>
                <xs:documentation>
                    Current count is put in the field attribute.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="check-errors" substitutionGroup="ControlOperations">
        <xs:annotation>
            <xs:documentation>
                The message lists from invoking are not checked until the check-errors tag is used.
                The named list is checked and if it contains any messages they are put in the servlet
                request object and the specified error code is returned to the control servlet.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" ref="error-prefix"/>
                <xs:element minOccurs="0" ref="error-suffix"/>
                <xs:element minOccurs="0" ref="message-prefix"/>
                <xs:element minOccurs="0" ref="message-suffix"/>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.check-errors"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.check-errors">
        <xs:attribute type="xs:string" name="error-code" default="error">
             <xs:annotation>
                <xs:documentation>
                    Defaults to "error".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of the list in the method environment to check for error messages.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="add-error" substitutionGroup="ControlOperations">
        <xs:annotation>
            <xs:documentation>
                Adds an error message with to the given error list from either an inline message or a message from a properties file.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.add-error"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.add-error">
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of the list in the method environment to check for error messages.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="return" substitutionGroup="ControlOperations">
        <xs:annotation>
            <xs:documentation>
                Returns immediately from the simple-method with the given response code string.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.return"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.return">
        <xs:attribute type="xs:string" name="response-code" default="success">
            <xs:annotation>
                <xs:documentation>
                    The string to return as a response code. Defaults to "success".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="assert" substitutionGroup="IfOtherOperations">
        <xs:annotation>
            <xs:documentation>
                Each condition under the assert element will be checked and if it fails an error will be added to the given error list.
                Note that while the definitions for the if-* operations are used, the tags should be empty because of the differing semantics.

                This is mainly used for testing, and for writing simple-methods that are meant to be used as part of a test suite.

                This is mostly useful for testing because the messages are targeted at a programmer, and not really at an end user.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group maxOccurs="unbounded" ref="IfConditions"/>
            <xs:attributeGroup ref="attlist.assert"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.assert">
        <xs:attribute type="xs:string" name="title">
            <xs:annotation>
                <xs:documentation>
                    Each assert operation have a title that can be used in the report for the testing.
                    These can be used in the normal code.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of the list in the method environment to check for error messages.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>

    <!--
        Operations that conditionally execute blocks within them; they mimic the
        simple-map-processor process operations that validate incoming data
    -->
    <xs:group name="IfConditions">
        <xs:choice>
            <xs:element ref="IfCombineConditions"/>
            <xs:element ref="IfBasicOperations"/>
        </xs:choice>
    </xs:group>
    <xs:element name="IfCombineConditions" abstract="true"/>
    <xs:element name="if" substitutionGroup="IfOtherOperations">
        <xs:annotation>
            <xs:documentation>
                The if operation offers a flexible way of specifying combinations of conditions, alternate conditions,
                and operations to run on true evaluation of the conditions or to run otherwise.

                The other if operations are meant for a specific, simple condition when used outside of the condition sub-element of this operation.
                The attributes of the other if operations are the same when used inside this operation.

                Note that while the definitions for the if-* operations are used, the tags should be empty because of the differing semantics.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="condition">
                    <xs:annotation>
                        <xs:documentation>
                            A simple element with no attributes that contains the condition that will be evaluated to determine which sub-operations to execute.
                            To combine the other if operations documented below the and, or, xor, and notelements can be used.
                            The and, or, and xor elements can contain as many general if operations and modifier/combination elements (ie and, or, xor, and not).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="then">
                    <xs:annotation>
                        <xs:documentation>
                            The then element is used to contain operations that will run if the condition evaluate to true.
                            A then tag must be included, but can be empty.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="else-if">
                    <xs:annotation>
                        <xs:documentation>
                            The else-if element can be used to specify alternate conditional execution blocks.
                            Each else-if element must contain two sub-elements: condition and then.
                            These operations are used the same as the condition and then elements describes above.
                            If the condition of the parent if element is evaluated to false, each condition of the else-if sub-elements will be evaluated,
                            and the operations under the then element corresponding first condition that evaluates to true will be run.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else element can be used to contain operations that will run if the condition evaluates to false, and if no else-ifsub-conditions evaluate to true.
                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="while" substitutionGroup="IfOtherOperations">
        <xs:annotation>
            <xs:documentation>
                While loop operation, uses the same condition element as the if operation.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="condition">
                    <xs:annotation>
                        <xs:documentation>
                            A simple element with no attributes that contains the condition that will be evaluated to determine which sub-operations to execute.
                            To combine the other if operations documented below the and, or, xor, and notelements can be used.
                            The and, or, and xor elements can contain as many general if operations and modifier/combination elements (ie and, or, xor, and not).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="then">
                    <xs:annotation>
                        <xs:documentation>
                            The then element is used to contain operations that will run if the condition evaluate to true.
                            A then tag must be included, but can be empty.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="condition">
        <xs:annotation>
            <xs:documentation>
                A simple element with no attributes that contains the condition that will be evaluated to determine which sub-operations to execute.
                To combine the other if operations documented below the and, or, xor, and notelements can be used.
                The and, or, and xor elements can contain as many general if operations and modifier/combination elements (ie and, or, xor, and not).
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group ref="IfConditions"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="then">
        <xs:annotation>
            <xs:documentation>
                The then element is used to contain operations that will run if the condition evaluate to true.
                A then tag must be included, but can be empty.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="else-if">
        <xs:annotation>
            <xs:documentation>
                The else-if element can be used to specify alternate conditional execution blocks.
                Each else-if element must contain two sub-elements: condition and then.
                These operations are used the same as the condition and then elements describes above.
                If the condition of the parent if element is evaluated to false, each condition of the else-if sub-elements will be evaluated,
                and the operations under the then element corresponding first condition that evaluates to true will be run.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="condition">
                    <xs:annotation>
                        <xs:documentation>
                            A simple element with no attributes that contains the condition that will be evaluated to determine which sub-operations to execute.
                            To combine the other if operations documented below the and, or, xor, and notelements can be used.
                            The and, or, and xor elements can contain as many general if operations and modifier/combination elements (ie and, or, xor, and not).
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="then">
                    <xs:annotation>
                        <xs:documentation>
                            The then element is used to contain operations that will run if the condition evaluate to true.
                            A then tag must be included, but can be empty.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="else">
        <xs:annotation>
            <xs:documentation>
                The else element can be used to contain operations that will run if the condition evaluates to false, and if no else-ifsub-conditions evaluate to true.
                It can contain any simple-method operation.
                The else tag must be placed as the last tag under the if tag.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="or" substitutionGroup="IfCombineConditions">
        <xs:annotation>
            <xs:documentation>
                To be true just one of the elements underneath needs to be true.
                The process will return (with true value) as soon as a condition is verified not evaluating remaining conditions if any.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group maxOccurs="unbounded" ref="IfConditions"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="xor" substitutionGroup="IfCombineConditions">
        <xs:annotation>
            <xs:documentation>
                To be true only one of the elements underneath can be true.
                The process will return (with false value) as soon as 2 conditions are verified not evaluating remaining conditions if any.
                If no conditions evaluate to true the process will return false.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group maxOccurs="unbounded" ref="IfConditions"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="and" substitutionGroup="IfCombineConditions">
        <xs:annotation>
            <xs:documentation>
                To be true all of the elements underneath need to be true.
                The process will return (with false value) as soon as a condition evaluates to false not evaluating remaining conditions if any.
                If no conditions evaluate to false the process will return true.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group maxOccurs="unbounded" ref="IfConditions"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="not" substitutionGroup="IfCombineConditions">
        <xs:annotation>
            <xs:documentation>
                Can only have one condition underneath and simply reverse the boolean value of this condition.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group ref="IfConditions"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="if-validate-method" substitutionGroup="IfBasicOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the if-validate-method tag will only be executed if the validate method returns true.
                If-validate-method calls a static Java method that takes a String and returns a boolean.
                This tag can contain any of the simple-method operations, including the conditional/if operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-validate-method"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-validate-method">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the field (variable) that will be validated.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="method" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method that will be called to validate the field.
                    It must be a static method that takes a single String parameter and return a boolean.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="class" default="org.ofbiz.base.util.UtilValidate">
            <xs:annotation>
                <xs:documentation>
                    The name of the class that contains the validation method. If not specified defaults to "org.ofbiz.base.util.UtilValidate".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="if-instance-of" substitutionGroup="IfBasicOperations">
        <xs:annotation>
            <xs:documentation>
                Checks if the field is an instance of the name class.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-instance-of"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-instance-of">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the map field that will be validated as being an instance of the named class.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="class" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the class that named instance in field-name is supposed to belong.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="if-compare" substitutionGroup="IfBasicOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the if-compare tag will only be executed if the comparison returns true.
                This tag can contain any of the simple-method operations, including the conditional/if operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-compare"/>
            <xs:attributeGroup ref="attlist.operatorRequired"/>
            <xs:attributeGroup ref="attlist.typeDefaultString"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-compare">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the field in the context (environment) that will be compared.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="value" use="required">
            <xs:annotation>
                <xs:documentation>
                    The value that the field will compared to.
                    Must be a String, but can be converted to other types.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="format">
            <xs:annotation>
                <xs:documentation>
                    Format based on the type of the object (date,number, etc.).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="if-compare-field" substitutionGroup="IfBasicOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the if-compare-field tag will only be executed if the comparison returns true.
                This tag can contain any of the simple-method operations, including the conditional/if operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-compare-field"/>
            <xs:attributeGroup ref="attlist.operatorRequired"/>
            <xs:attributeGroup ref="attlist.typeDefaultString"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-compare-field">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the context field that will be compared.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="to-field">
            <xs:annotation>
                <xs:documentation>
                    The name of the context field that the main field will be compared to.
                    If left empty will default to the field attribute's value.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="format">
            <xs:annotation>
                <xs:documentation>
                    Format based on the type of the object (date,number, etc.).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="if-regexp" substitutionGroup="IfBasicOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the if-regexp tag will only be executed if the value complies with the regular expression.
                This tag can contain any of the simple-method operations, including the conditional/if operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-regexp"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-regexp">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the map field that will be compared.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="expr" use="required">
            <xs:annotation>
                <xs:documentation>
                    A regular expression that the map value must comply with.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="if-empty" substitutionGroup="IfBasicOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the if-empty tag will only be executed if the map field is empty.
                This tag can contain any of the simple-method operations, including the conditional/if operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-empty"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-empty">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the context field that will be compared.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="if-not-empty" substitutionGroup="IfOtherOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the if-not-empty tag will only be executed if the map field is not empty.
                This tag can contain any of the simple-method operations, including the conditional/if operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-not-empty"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-not-empty">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the context field that will be compared.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="if-has-permission" substitutionGroup="IfBasicOperations">
        <xs:annotation>
            <xs:documentation>
                The operations contained by the if-has-permission tag will only be executed if the user has the specified permission, and optionally the action.
                This tag can contain any of the simple-method operations, including the conditional/if operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations">
                    <xs:annotation>
                        <xs:documentation>
                            Any simple-method operation can be nested under an if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:group>
                <xs:element minOccurs="0" ref="else">
                    <xs:annotation>
                        <xs:documentation>
                            The else tag can be used to contain operations that will run if the condition fails,
                            or in other words if the operations under the if tag do not run.

                            It can contain any simple-method operation.
                            The else tag must be placed as the last tag under the if-* tag.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.if-has-permission"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.if-has-permission">
        <xs:attribute type="xs:string" name="permission" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the permission in the database.
                    The user must belong to a security group that has this permission.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="action">
            <xs:annotation>
                <xs:documentation>
                    If an action is specified the user can have one of two permissions: the permission + "_ADMIN" or permission + action.
                    Examples of actions include "_CREATE", "_VIEW", etc.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="check-permission" substitutionGroup="IfOtherOperations">
        <xs:annotation>
            <xs:documentation>
                The check-permission tag checks to see if the current user has the specified permission.
                The the user does not have the specified permission or there is no user associated with the context
                then the failure message from fail-message or file-property will be added to the specified error list.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="1" ref="accept-userlogin-party"/>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="alt-permission"/>
                <xs:choice>
                    <xs:element ref="fail-message"/>
                    <xs:element ref="fail-property"/>
                </xs:choice>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.check-permission"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.check-permission">
        <xs:attribute type="xs:string" name="permission" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the permission in the database.
                    The user must belong to a security group that has this permission.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="action">
            <xs:annotation>
                <xs:documentation>
                    If an action is specified the user can have one of two permissions: the permission + "_ADMIN" or permission + action.
                    Examples of actions include "_CREATE", "_VIEW", etc.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of a list in the method environment that the error messages will be added to.
                    Will be created if does not exist.
                    Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="accept-userlogin-party">
        <xs:annotation>
            <xs:documentation>
                If that tag is present userlogin party is accepted, rather than requiring that the user have the permission.

                Often used in cases where you want to allow a user to for example see their own order, or update their own contact information.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.accept-userlogin-party"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.accept-userlogin-party">
        <xs:attribute type="xs:string" name="party-id-env-name" default="partyId">
            <xs:annotation>
                <xs:documentation>
                    Environment variable name used (defaults to partyId),
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="alt-permission">
        <xs:annotation>
            <xs:documentation>
                Allows to specify a number of alternate permissions, any of which will satisfy this check permission.
                If the current userLogin does not have any of these permissions the error will be added to the list.
                If the user has any of the alt-permissions, they subsume standard permissions.

                This tag basically has the same attributes as the check-permission tag, permission and action.
                Just as the corresponding attributes for the check-permission element.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.alt-permission"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.alt-permission">
        <xs:attribute type="xs:string" name="permission" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the permission in the database.
                    The user must belong to a security group that has this permission.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="action">
            <xs:annotation>
                <xs:documentation>
                    If an action is specified the user can have one of two permissions: the permission + "_ADMIN" or permission + action.
                    Examples of actions include "_CREATE", "_VIEW", etc.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="check-id" substitutionGroup="IfOtherOperations">
        <xs:annotation>
            <xs:documentation>
                <![CDATA[The check-id tag checks to see if the ID value in the given field is a valid ID string.
                Valid IDs can be any sequence of characters or digits but must not containt the following characters:
                space [ ], doublequote ["], single quote ['], ampersand [&], question mark [?], less-than sign [<], greater-than sign [>].]]>
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0">
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.check-id"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.check-id">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the field that contains the ID value to check.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="error-list-name" default="error_list">
            <xs:annotation>
                <xs:documentation>
                    The name of a list in the method environment that the error messages will be added to.
                    Will be created if does not exist. Defaults to "error_list".
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- the "Other" Operations -->
    <xs:element name="log" substitutionGroup="OtherOperations">
        <xs:annotation>
            <xs:documentation>
                The log tag logs a message used the OFBiz Debug class, which uses Log4J to log to the console, a file, or some other location.
                The message is a concatenation of the message attribute and then all of the field and string sub-element values in the order they are specified.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="field">
                    <xs:annotation>
                        <xs:documentation>
                            Inserts the value of the field into the message where specified.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="string">
                    <xs:annotation>
                        <xs:documentation>
                            Inserts the value of the inline string into the message where specified.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:choice>
            <xs:attributeGroup ref="attlist.log"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.log">
        <xs:attribute name="level" use="required">
            <xs:annotation>
                <xs:documentation>
                    The logging/debug level to use.
                    Must be one of the following: verbose | timing | info | important | warning | error | fatal | always.
                    These are the standard OFBiz logging levels.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="verbose"/>
                    <xs:enumeration value="timing"/>
                    <xs:enumeration value="info"/>
                    <xs:enumeration value="important"/>
                    <xs:enumeration value="warning"/>
                    <xs:enumeration value="error"/>
                    <xs:enumeration value="fatal"/>
                    <xs:enumeration value="always"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="message">
            <xs:annotation>
                <xs:documentation>
                    A shortcut for simple messages.
                    If used along with field and/or string sub-elements the inline string in the message will come first.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="now-timestamp" substitutionGroup="OtherOperations">
        <xs:annotation>
            <xs:documentation>
                The now-timestamp tag creates a java.sql.Timestamp object with the current date and time in it and puts it in a field in the method environment.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.now-timestamp"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.now-timestamp">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field the timestamp will be put in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="now-date-to-env" substitutionGroup="OtherOperations">
        <xs:annotation>
            <xs:documentation>
                The now-date-to-env tag creates a java.sql.Date object with the current date in it and puts it in a field in the method environment.
            </xs:documentation>
        </xs:annotation><xs:complexType>
            <xs:attributeGroup ref="attlist.now-date-to-env"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.now-date-to-env">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field the date will be put in.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="property-to-field" substitutionGroup="OtherOperations">
        <xs:annotation>
            <xs:documentation>
                The property-to-field tag puts the inlined string value in the specified field.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.property-to-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.property-to-field">
        <xs:attribute type="xs:string" name="resource" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a properties file on the classpath.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="property" use="required">
            <xs:annotation>
                <xs:documentation>
                    The property whose value will be put in the field.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name (key) of the map field to use.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default">
            <xs:annotation>
                <xs:documentation>
                    The default value to use if the specified property is empty.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="no-locale" default="false">
            <xs:annotation>
                <xs:documentation>
                    If sets to true don't use the default locale variable.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="arg-list-name"/>
    </xs:attributeGroup>
    <xs:element name="set-current-user-login" substitutionGroup="OtherOperations">
        <xs:annotation>
            <xs:documentation>
                The set-current-user-login tag sets the UserLogin GenericValue object to be used for authentication for the rest of the method.
                This is mostly used for calling services, etc.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.set-current-user-login"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.set-current-user-login">
        <xs:attribute type="xs:string" name="value-field" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the method environment field that contains the UserLogin GenericValue object.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="calculate" substitutionGroup="OtherOperations">
        <xs:annotation>
            <xs:documentation>
                The calculate tag performs the specified calculation and puts the result in an object in the field of the specified map (see the calculate element attribute descriptions).
                The type of the object can be specified with the type attribute, defaults to Double.

                The calculate tag can contain calcop and number tags, and the calcop tag can also contain these two tags to enable nested calculations.

                The operator specifies the operation to perform on the given field and nested calcops and numbers.
                It must be one of the following: get | add | subtract | multiply | divide | negative.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="calcop">
                    <xs:annotation>
                        <xs:documentation>
                            This tag is used to apply an operator in the calculation.
                            It can have calcop and number tags nested under it, making it also act like a parenthesis.
                            It has three attributes: operator, map-name, and field-name. Operator and field-name are required.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element ref="number"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.calculate"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.calculate">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation><xs:documentation>The name (key) of the map (or env if map-name is empty) field to use.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" default="BigDecimal">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="String"/>
                    <xs:enumeration value="Double"/>
                    <xs:enumeration value="Float"/>
                    <xs:enumeration value="Long"/>
                    <xs:enumeration value="Integer"/>
                    <xs:enumeration value="BigDecimal"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="rounding-mode" default="HalfEven">
            <xs:annotation>
                <xs:documentation>
                    Rounding mode for BigDecimal calculation, primarily for divide operation.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="Ceiling"><xs:annotation><xs:documentation>Rounding mode to round towards positive infinity</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="Floor"><xs:annotation><xs:documentation>Rounding mode to round towards negative infinity</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="Up"><xs:annotation><xs:documentation>Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round up</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="Down"><xs:annotation><xs:documentation>Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round down</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="HalfUp"><xs:annotation><xs:documentation>Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round up</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="HalfDown"><xs:annotation><xs:documentation>Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round down</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="HalfEven"><xs:annotation><xs:documentation>Rounding mode to round towards the "nearest neighbor" unless both neighbors are equidistant, in which case, round towards the even neighbor</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="Unnecessary"><xs:annotation><xs:documentation>Rounding mode to assert that the requested operation has an exact result, hence no rounding is necessary</xs:documentation></xs:annotation></xs:enumeration>
                    <xs:enumeration value="${roundingMode}"><xs:annotation><xs:documentation>Convention for variable name for this attribute, in cases where it is determined at run-time.</xs:documentation></xs:annotation></xs:enumeration>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="decimal-scale" default="2">
            <xs:annotation><xs:documentation>Initial scale to use for the internal BigDecimal. Defaults to 2 for monetary calculations.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="decimal-format"/>
    </xs:attributeGroup>
    <xs:element name="calcop">
        <xs:annotation>
            <xs:documentation>
                The calcop tag has an operator: get, add, subtract, multiply, divide, and negative.
                So add, subtract, multiply, and divide are just the basic arithmetic operations.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="calcop"/>
                <xs:element ref="number"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.calcop"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.calcop">
        <xs:attribute name="operator" use="required">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="get">
                        <xs:annotation>
                            <xs:documentation>
                                Gets the positive value.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="add"/>
                    <xs:enumeration value="subtract"/>
                    <xs:enumeration value="multiply"/>
                    <xs:enumeration value="divide"/>
                    <xs:enumeration value="negative">
                        <xs:annotation>
                            <xs:documentation>
                                Negates the value
                            </xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="field">
            <xs:annotation>
                <xs:documentation>
                    The name (key) of the map field to use.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="number">
        <xs:annotation>
            <xs:documentation>
                This is used to put a numeric constant (a number) into the calculation.
                It has one attribute: value. This must be a properly formatted number or an error will result.
                May use flexible string.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.number"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.number">
        <xs:attribute type="xs:string" name="value" use="required">
            <xs:annotation>
                <xs:documentation>
                    Literal or flexible string.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="set-calendar" substitutionGroup="OtherOperations">
        <xs:annotation>
            <xs:documentation>
                The set-calendar tag allows to set a date "field" from another "from-field" date field type
                or directly from a value using at least one adjuster to modify the from-field date.
                The type of fields or value is Timestamp.

                Again you can use the flexible string expander here, the ${} syntax and such. It can also do a type conversion,
                so going from whatever type the source data is in, which would be a string value or whatever the variable
                type is for a from field, it can convert that to any ofthese types before setting it in the target field.

                You can also specify a default value in the case that the value evaluates to an empty string or the from-field is
                null or empty. Then the default-value will be used.

                Adjuster years, months, days, hours, minutes, seconds and millis use integers optionally precedeed by + or -
                Period-align-start and period-align-end allows to align on end or start of a period.

                You may specify a locale or a time-zone else the respective default request value is used.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.set-calendar"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.set-calendar">
        <xs:attribute type="xs:string" name="field" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the field to copy value to.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="from-field">
            <xs:annotation>
                <xs:documentation>
                    Name of the field to copy value from.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="value">
            <xs:annotation>
                <xs:documentation>
                    Simple value to copy in field.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="default-value">
            <xs:annotation>
                <xs:documentation>
                    Default value to copy in field if value evaluates to an empty string or the from-field is null or empty.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="set-if-null" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not to set fields that are null or empty.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="set-if-empty" default="true">
            <xs:annotation>
                <xs:documentation>
                    If the source value, either from a value or from a field, is empty, and
                    empty-string an empty list or a null value.
                    In this case it's set to true.

                    If you don't want to set, if you want it to
                    leave the target field alone when the source is empty,
                    then you need to set this to false.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="years">
            <xs:annotation>
                <xs:documentation>
                    Add (optionally using +) or subtract (using -) a number of year(s).
                    If an expression is used, it should evaluate to an integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="months">
            <xs:annotation>
                <xs:documentation>
                    Add (optionally using +) or subtract (using -) a number of month(s).
                    If an expression is used, it should evaluate to an integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="days">
            <xs:annotation>
                <xs:documentation>
                    Add (optionally using +) or subtract (using -) a number of days(s).
                    If an expression is used, it should evaluate to an integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="hours">
            <xs:annotation>
                <xs:documentation>
                    Add (optionally using +) or subtract (using -) a number of hour(s).
                    If an expression is used, it should evaluate to an integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="minutes">
            <xs:annotation>
                <xs:documentation>
                    Add (optionally using +) or subtract (using -) a number of minute(s).
                    If an expression is used, it should evaluate to an integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="seconds">
            <xs:annotation>
                <xs:documentation>
                    Add (optionally using +) or subtract (using -) a number of second(s).
                    If an expression is used, it should evaluate to an integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="millis">
            <xs:annotation>
                <xs:documentation>
                    Add (optionally using +) or subtract (using -) a number of milli-second(s).
                    If an expression is used, it should evaluate to an integer.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="period-align-start">
            <xs:annotation>
                <xs:documentation>
                    Align the returned date to the start of the chosen adjustment between year, month, week or day.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="year"/>
                    <xs:enumeration value="month"/>
                    <xs:enumeration value="week"/>
                    <xs:enumeration value="day"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="period-align-end">
            <xs:annotation>
                <xs:documentation>
                    Align the returned date to the end of the chosen adjustment between year, month, week or day.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="year"/>
                    <xs:enumeration value="month"/>
                    <xs:enumeration value="week"/>
                    <xs:enumeration value="day"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="locale">
            <xs:annotation>
                <xs:documentation>
                    A locale value (eg: en)
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="time-zone">
            <xs:annotation>
                <xs:documentation>
                    a time zone value (eg: GMT)
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
        ======================================================
        ========== The Simple Map Processor Section ==========
        ======================================================
    -->
    <xs:element name="simple-map-processors">
        <xs:complexType>
            <xs:sequence>
                <xs:element maxOccurs="unbounded" ref="simple-map-processor"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="simple-map-processor">
        <xs:annotation>
            <xs:documentation>
                The Simple Map Processor Mini-Language performes two primary tasks: validation and conversion.
                It does this in a context of moving values from one Map to another.
                The input map will commonly contain Strings, but can contain other object types like
                Integer, Long, Float, Double, java.sql.Date, Time, and Timestamp.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="make-in-string"/>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="process"/>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.simple-map-processor"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.simple-map-processor">
        <xs:attribute type="xs:string" name="name" use="required"/>
    </xs:attributeGroup>
    <!-- Make In String & Operations -->
    <xs:element name="make-in-string">
        <xs:annotation>
            <xs:documentation>
                In addition to dealing with the fields already in the incoming Map you can build Strings and add them to the in-Map before the processing begins with the make-in-string tag.
                You can have zero or many make-in-string tags, and they must all come before the process tags.
                Inside each make-in-string is a list of snippets to concatenate together to make the final String.
                Each snippet can be another field in the in-Map (in-field element), a value from a properties file (property element), or a constant (constant element).
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="in-field"/>
                <xs:element ref="property"/>
                <xs:element ref="constant"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.make-in-string"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.make-in-string">
        <xs:attribute type="xs:string" name="field" use="required"/>
    </xs:attributeGroup>
    <xs:element name="in-field">
        <xs:annotation>
            <xs:documentation>
                Name of one of the incoming fields, or one of the fields in the in-map to add to the string.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.in-field"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.in-field">
        <xs:attribute type="xs:string" name="field" use="required"/>
    </xs:attributeGroup>
    <xs:element name="property">
        <xs:annotation>
            <xs:documentation>
                Load the value of a property from a resourcebundle properties file, with the given resource
                on the classpath, and the name of the property in that file.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.property"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.property">
        <xs:attribute type="xs:string" name="resource" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a properties file on the classpath.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="property" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the property in the resource attribute file.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="constant" type="xs:string">
        <xs:annotation>
            <xs:documentation>
                Any simple literal value.
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- Field Process & Operations -->
    <xs:element name="process">
        <xs:annotation>
            <xs:documentation>
                The process tag is used to contain the operations to be done on the specified field in the in-Map.
                It has one required attribute, the field to operate on.
                The operations that it contains are: validate-method, compare, compare-field, regexp, not-empty, copy, and convert.

                All process operations tags except copy must contain one of two tags: fail-message or fail-property.
                If the operation fails a message is added to the message list that is either the specified fail-message, or the String from the properties file value that is specified in fail-property.

                Messages are collected in List as the Simple Map Processor runs.
                If the List is not empty when it completes then something failed in the map processor.
                This is done so that all failures will be reported immediately rather than having to fix one failure before another can be discovered.

                All process operations automatically convert the field value and other values from their current type to the type specified for the operation, where applicable.
                The ObjectType.simpleTypeConvert method is used to do the conversion.
                It supports the following types: String, Double, Float, Long, Integer, Date, Time, and Timestamp.
                If the type is not specified String is the default.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="validate-method"/>
                <xs:element ref="compare"/>
                <xs:element ref="compare-field"/>
                <xs:element ref="regexp"/>
                <xs:element ref="not-empty"/>
                <xs:element ref="copy"/>
                <xs:element ref="convert"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.process"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.process">
        <xs:attribute type="xs:string" name="field" use="required"/>
    </xs:attributeGroup>
    <xs:element name="validate-method">
        <xs:annotation>
            <xs:documentation>
                The validate-method tag is used to call any static method that accepts a String and returns a boolean.
                If the field coming in is not a String it will be converted to a String before calling the method.
                The two attributes for this tag are class and method which should contain the fully qualified class name and the method name, respectively.
                If the class name is not specified it will default to org.ofbiz.base.util.UtilValidate.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.validate-method"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.validate-method">
        <xs:attribute type="xs:string" name="method" use="required"/>
        <xs:attribute type="xs:string" name="class" default="org.ofbiz.base.util.UtilValidate"/>
    </xs:attributeGroup>
    <xs:element name="compare">
        <xs:annotation>
            <xs:documentation>
                The compare tag is used to compare the field value to the value specified in the value attribute.
                An operator must be specified to indicate the comparison desired.
                Operators available include less, greater, less-equals, greater-equals, equals, not-equals, and contains.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.compare"/>
            <xs:attributeGroup ref="attlist.operatorRequired"/>
            <xs:attributeGroup ref="attlist.typeDefaultString"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.compare">
        <xs:attribute type="xs:string" name="value" use="required">
            <xs:annotation>
                <xs:documentation>
                    Literal or flexible string using ${} syntax.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="format">
            <xs:annotation>
                <xs:documentation>
                    Format based on the type of the object (date,number, etc.).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="compare-field">
        <xs:annotation>
            <xs:documentation>
                The compare-field tag is just like the compare tag except that instead of specifying a value you specify the name of another field in the in-Map to compare the current field to.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.compare-field"/>
            <xs:attributeGroup ref="attlist.operatorRequired"/>
            <xs:attributeGroup ref="attlist.typeDefaultString"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.compare-field">
        <xs:attribute type="xs:string" name="field" use="required"/>
        <xs:attribute type="xs:string" name="format">
            <xs:annotation>
                <xs:documentation>
                    Format based on the type of the object (date,number, etc.).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="regexp">
        <xs:annotation>
            <xs:documentation>
                The regexp tag validate the current field against the regular expression specified in the expr attribute of the tag.
                Standard Perl style regular expressions are used with the ORO library from Jakarta.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.regexp"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.regexp">
        <xs:attribute type="xs:string" name="expr" use="required"/>
    </xs:attributeGroup>
    <xs:element name="not-empty">
        <xs:annotation>
            <xs:documentation>
                The not-empty tag verifies that the current field is not empty.
                If the field is a String it must not be null and must have a length greater than zero,
                otherwise it must simply not be null and you will get the fail-message or fail-property.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>
    <xs:element name="copy">
        <xs:annotation>
            <xs:documentation>
                The copy operation simply copies the current field value to the out-Map from the in-Map.
                There are three optional attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.copy"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.copy">
        <xs:attribute type="xs:string" name="to-field">
            <xs:annotation>
                <xs:documentation>
                    If a different field name is desired in the out-Map it can be specified in the to-field attribute.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="replace" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specify if an existing field in the out-Map should be replaced or not, defaults to true.
                    If you set it to false then it will look in the out-map,
                    and if it finds a value of the same name already there it will not copy over top of that value.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="set-if-null" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not to set fields that are null or empty.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="convert">
        <xs:annotation>
            <xs:documentation>
                The convert tag does the same thing as copy except that the type can be converted to the type specified in the type attribute.
                The format attribute can be used to specify the format for date/time fields.
                These two tags are in addition to all of the the attributes in the copy tag.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element ref="fail-message"/>
                <xs:element ref="fail-property"/>
            </xs:choice>
            <xs:attributeGroup ref="attlist.convert"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.convert">
        <xs:attribute type="xs:string" name="to-field">
            <xs:annotation>
                <xs:documentation>
                    If no to-field is specified, it is the same as the field on process.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" use="required">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="PlainString"/>
                    <xs:enumeration value="String"/>
                    <xs:enumeration value="BigDecimal"/>
                    <xs:enumeration value="Double"/>
                    <xs:enumeration value="Float"/>
                    <xs:enumeration value="Long"/>
                    <xs:enumeration value="Integer"/>
                    <xs:enumeration value="Date"/>
                    <xs:enumeration value="Time"/>
                    <xs:enumeration value="Timestamp"/>
                    <xs:enumeration value="Boolean"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="replace" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specify if an existing field in the out-Map should be replaced or not, defaults to true.
                    If you set it to false then it will look in the out-map,
                    and if it finds a value of the same name already there it will not copy over top of that value.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="set-if-null" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether or not to set fields that are null or empty.
                    Defaults to true.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute type="xs:string" name="format">
            <xs:annotation>
                <xs:documentation>
                    Format based on the type of the object (date,number, etc.).
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- Failure stuff: inline message or from a properties file -->
    <xs:element name="fail-message">
        <xs:annotation>
            <xs:documentation>
                Used to specify an inline message. Has one attribute called 'message'.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.fail-message"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.fail-message">
        <xs:attribute type="xs:string" name="message" use="required">
            <xs:annotation>
                <xs:documentation>
                    Literal or flexible string using ${} syntax.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:element name="fail-property">
        <xs:annotation>
            <xs:documentation>
                Used to get the message from a properties file. Has two attributes: resource and property.
                Typically used for internationalized messages.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="attlist.fail-property"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.fail-property">
        <xs:attribute type="xs:string" name="resource" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of a properties file on the classpath.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute type="xs:string" name="property" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the property in the properties file qualifed by 'resource'.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
</xs:schema>
